# Initially generated by PNCconf at Thu Feb 13 15:05:10 2025
# Using LinuxCNC version:  Master (2.9)
# If you make changes to this file, they will be
# overwritten when you run PNCconf again

# ************************************************************
# Updated 2025-03-14 by R. Colvin
#   1. Add commentary on each field (if it could be found) to 
#       enable modifications later as necessary.
#   2. Details outlined in Rosetta_ini.xlsx on shared drive
#       Ver 0.1
# ************************************************************
# Updated 2025-02-13 by R. Colvin
#   1. Changed A axis to C
#   2. Added B, U, & V axes
# ************************************************************
# Configuration values
#
#                                 Home
#  Axis  Joint  Channel   Type     Seq
#  ----  -----  -------  -------  ----
#   X      0       02	 LINEAR     1
#   Y      1       03	 LINEAR     2
#   Z      2       00	 LINEAR     3
#   A     n/a     n/a	   n/a     n/a
#   B      3       06	 ANGULAR    4
#   C      4       07	 ANGULAR    5
#   U      5       04	 LINEAR     6
#   V      6       01	 LINEAR     7
#   W     n/a     n/a	   n/a     n/a
#   Sp     7       05	   n/a     n/a

[EMC]
# This is the name of the controller, which is printed out at the top
# of most graphical interfaces. You can put whatever you want here as
# long as you make it a single line long.
MACHINE = Rosetta
# Debug level 0 means no messages will be printed when LinuxCNC is
# run from a terminal. Debug flags are usually only useful to 
# developers. See src/emc/nml_intf/debugflags.h for other settings.
DEBUG = 0
# The version number for the configuration. Any value other than 1.1
# will cause the configuration checker to run and try to update the
# configuration to the new style joint axes type of configuration.
VERSION = 1.1

[DISPLAY]
# Prominent valid options are (all in lower case): 
#       axis, touchy, gmoccapy, gscreen, tklinuxcnc, qtvcp, 
#       qtvcp-qtdragon or qtvcp-qtplasmac
DISPLAY = axis
# The coordinate system (RELATIVE or MACHINE) to show on the DRO when
# the user interface starts. The RELATIVE coordinate system reflects
# the G92 and G5x coordinate offsets currently in effect.
POSITION_OFFSET = RELATIVE
# The coordinate value (COMMANDED or ACTUAL) to show on the DRO when
# the user interface starts. In AXIS this can be changed from the
# View menu. The COMMANDED position is the position requested by
# LinuxCNC. The ACTUAL position is the feedback position of the motors
# if they have feedback like most servo systems. Typically the
# COMMANDED value is used.
POSITION_FEEDBACK = ACTUAL
# The maximum feed override the user may select. 1.2 means 120% of
# the programmed feed rate.
MAX_FEED_OVERRIDE = 2.000000
# The minimum spindle override the user may select. 0.5 means 50% of
# the programmed spindle speed. (This is used to set the minimum 
# spindle speed.) On multi spindle machine there will be entries for
# each spindle number. Only used by the QtVCP based user interfaces.
MAX_SPINDLE_OVERRIDE = 1.000000
# The minimum spindle override the user may select. 0.5 means 50%
# of the programmed spindle speed. (This is used to set the minimum
# spindle speed.)
# MIN_SPINDLE_OVERRIDE = 0.500000
MIN_SPINDLE_OVERRIDE = 0.001000
# The image shown on the splash screen.
# INTRO_GRAPHIC = linuxcnc.gif
INTRO_GRAPHIC = Rosetta.gif
# The maximum time to show the splash screen, in seconds.
# INTRO_TIME = 5
INTRO_TIME = 10
# The default directory for G-code files, named subroutines, and
# user-defined M-codes. The PROGRAM_PREFIX directory is searched
# before the directories listed in [RS274]SUBROUTINE_PATH and
# [RS274]USER_M_PATH.
PROGRAM_PREFIX = /home/cnc/linuxcnc/nc_files
# Defines the increments available for incremental jogs. The INCREMENTS
# can be used to override the default. The values can be decimal
# numbers (e.g., 0.1000) or fractional numbers (e.g., 1/16), optionally 
# followed by a unit (cm, mm, um, inch, in or mil). If a unit is not
# specified the machine unit is assumed. Metric and imperial distances
# may be mixed:
#     INCREMENTS = 1 inch, 1 mil, 1 cm, 1 mm, 1 um is a valid entry.
INCREMENTS = .1in .05in .01in .005in .001in .0005in .0001in
POSITION_FEEDBACK = ACTUAL
# The default velocity for linear jogs, in machine units per second.
DEFAULT_LINEAR_VELOCITY = 0.250000
# The maximum velocity for linear jogs, in machine units per second.
MAX_LINEAR_VELOCITY = 1.000000
# The approximate lowest value the jog slider.
MIN_LINEAR_VELOCITY = 0.016670
# The default velocity for angular jogs, in machine units per second.
DEFAULT_ANGULAR_VELOCITY = 12.000000
# The maximum velocity for angular jogs, in machine units per second.
MAX_ANGULAR_VELOCITY = 180.000000
# The approximate lowest value the angular jog slider.
MIN_ANGULAR_VELOCITY = 1.666667
# The editor to use when selecting File > Edit to edit the G-code from
# the AXIS menu. This must be configured for this menu item to work. 
# Another valid entry is gnome-terminal -e vim. 
# This entry does not apply to GMOCCAPY, as GMOCCAPY has an integrated
# editor.
EDITOR = gedit
# Controls the preview and backplot of motion. This item consists of a
# sequence of axis letters and control characters, optionally preceded
# with a ”-” sign:
#   1. The letters X, Y, Z specify translation along the named
#      coordinate.
#   2. The letters A, B, C specify rotation about the corresponding 
#      axes X, Y, Z.
#   3. The letters U, V, W specify translation along the related axes 
#      X, Y, Z.
#   4. Each letter specified must occur in [TRAJ]COORDINATES to have
#      an effect.
#   5. A ”-” character preceding any letter inverts the direction of 
#      the operation.
#   6. The translation and rotation operations are evaluated right-to-
#      left. So using GEOMETRY=XYZBC specifies a C rotation followed 
#      by a B rotation followed by Z, Y, X translations. The ordering
#      of consecutive translation letters is immaterial.
#   7. The proper GEOMETRY string depends on the machine configuration
#      and the kinematics used to control it. The order of the letters
#      is important. For example, rotating around C then B is different
#      than rotating around B then C.
#   8. Rotations are by default applied with respect to the machine 
#      origin. Example: GEOMETRY=CXYZ first translates the control 
#      point to X, Y, Z and then performs a C rotation about the Z axis
#      centered at the machine origin.
#   9. UVW translation example: GEOMETRY=XYZUVW causes UVW to move in
#      the coordinate system of the tool and XYZ to move in the 
#      coordinate system of the material.
#   10. Foam-cutting machines (FOAM = 1) should specify ”XY;UV” or
#      leave the value blank even though this value is presently
#      ignored in foam-cutter mode. A future version may define what 
#      ”;” means, but if it does ”XY;UV” will mean the same as the 
#      current foam default.
#   11. Experimental: If the exclamation mark (!) character is included
#      in the GEOMETRY string, display points for A, B, C rotations
#      respect the X, Y, Z offsets set by G5x, G92 codes. Example:
#      Using GEOMETRY = !CXZ for a machine with [TRAJ]COORDINATES=XZC. 
#      This provision applies for liveplots only — G-code previews 
#      should be done with zero G5x, G92 offsets. This can be 
#      facilitated by setting offsets in programs only when task is
#      running as indicated by #<_task>== 1. If nonzero offsets exist 
#      at startup due to persistence, offsets should be zeroed and 
#      preview reloaded.
# GEOMETRY = xyz
GEOMETRY = XYZBCUV
# Cycle time of the display GUI. Depending on the screen, this can be
# in seconds or ms (ms preferred). This is often the update rate rather
# then sleep time between updates. If the update time is not set right
# the screen can become unresponsive or very jerky. A value of 100 ms
# (0.1 s) is a common setting though a range of 50 - 200 ms 
# (.05 - .2 s) may be useable. An under powered CPU may see improvement
# with a longer setting. Usually the default is fine.
CYCLE_TIME = 100
# Any non-empty value (including ”0”) causes axis to use ”lathe mode”
# with a top view and with Radius and Diameter on the DRO.
LATHE = 1

[FILTER]
# AXIS and GMOCCAPY have the ability to send loaded files through a 
# filter program. This filter can do any desired task: Something as
# simple as making sure the file ends with M2, or something as
# complicated as detecting whether the input is a depth image, and
# generating G-code to mill the shape it defines. The [FILTER] section
# of the INI file controls how filters work. First, for each type of 
# file, write a PROGRAM_EXTENSION-line. Then, specify the program to 
# execute for each type of file. This program is given the name of the 
# input file as its first argument, and must write RS274NGC code to
# standard output. This output is what will be displayed in the text 
# area, previewed in the display area, and executed by LinuxCNC when
# Run.
PROGRAM_EXTENSION = .png,.gif,.jpg Greyscale Depth Image
PROGRAM_EXTENSION = .py Python Script
png = image-to-gcode
gif = image-to-gcode
jpg = image-to-gcode
py = python

[TASK]
# Specifies the name of the task executable. The task executable does 
# various things, such as 
#   – communicate with the UIs over NML,LinuxCNC V2.9.4-15-ge41227b0f3, 
#     25 Jan 2025 152 / 1292
#   – communicate with the realtime motion planner over non-HAL shared 
#     memory, and
#   – interpret G-code. Currently there is only one task executable 
#     that makes sense for 99.9% of users, milltask.
TASK = milltask
# The period, in seconds, at which TASK will run. This parameter
# affects the polling interval when waiting for motion to complete, 
# when executing a pause instruction, and when accepting a command from
# a user interface. There is usually no need to change this number.
CYCLE_TIME = 0.010

[RS274NGC]
# The file located in the same directory as the INI file which contains
# the parameters used by the interpreter (saved between runs).
PARAMETER_FILE = linuxcnc.var
# A string of NC codes that the interpreter is initialized with. This
# is not a substitute for specifying modal G-codes at the top of each
# NGC file, because the modal codes of machines differ, and may be 
# changed by G-code interpreted earlier in the session.
RS274NGC_STARTUP_CODE = G20 G40 G90 G94 G97 G64 P0.001
# 
# Other parameters are outlined in the documentation.

[EMCMOT]
# The motion controller name is typically used here.
EMCMOT = motmod
# Number of seconds to wait for Motion (the realtime part of the motion 
# controller) to acknowledge receipt of messages from Task (the non-
# realtime part of the motion controller).
COMM_TIMEOUT = 1.0
# This is the ”Servo” task period in nanoseconds.
SERVO_PERIOD = 1000000

[HMOT]
# **** This is for info only ****
CARD0=hm2_7i92.0

[HAL]
# Adds the HAL user interface pins.
HALUI = halui
# Execute this file at start up.
# If HALFILE is specified multiple times, the files are interpreted 
# in the order they appear in the INI file. HAL files are descriptive,
# the execution of what is described in HAL files is triggered by the 
# threads in which functions are embedded, not by the reading of the
# HAL file. Almost all configurations will have at least one HALFILE,
# and stepper systems typically have two such files, i.e., one which
# specifies the generic stepper configuration (core_stepper.hal) and
# one which specifies the machine pin out (xxx_pinout.hal).
# HAL files specified in the HALFILES variable are found using a 
# search. If the named file is found in the directory containing the
# INI file, it is used. If the named file is not found in this INI
# file directory, a search is made using a system library of HAL files.
# If LinuxCNC is started with the linuxcnc script using the ”-H dirname”
# option, the specified dirname is prepended to the search described
# above so that dirname is searched first. The ”-H dirname” option may
# be specified more than once, directories are prepended in order.
# A HALFILE may also be specified as an absolute path (when the name s
# tarts with a / character). Absolute paths are not recommended as their use may limit relocation of configurations.
HALFILE = Rosetta.hal
HALFILE = custom.hal
# Execute this file after the GUI has created its HAL pins. Some GUIs 
# create HAL pins and support the use of a postgui halfile to use them. 
# GUIs that support postgui HAL files include Touchy, AXIS, Gscreen, 
# and GMOCCAPY. 
POSTGUI_HALFILE = custom_postgui.hal
# Execute this file when LinuxCNC is exiting. Depending on the hardware
# drivers used, this may make it possible to set outputs to defined 
# values when LinuxCNC is exited normally. However, because there is 
# no guarantee this file will be executed (for instance, in the case of
# a computer crash), it is not a replacement for a proper physical 
# e-stop chain or other protections against software failure.
SHUTDOWN = shutdown.hal

[HALUI]

[KINS]
# Specifies the number of joints (motors) in the system. For example,
# a trivkins XYZ machine with a single motor for each axis has 3
# joints. A gantry machine with one motor on each of two of the axes,
# and two motors on the third axis, has 4 joints. (This config variable
# may be used by a GUI to set the number of joints (num_joints)
# specified to the motion module (motmod).)
# JOINTS = 4
JOINTS = 7
# Specify a kinematics module for the motion module. GUIs may use this
# variable to specify the loadrt-line in HAL files for the motmod
# module. For more information on kinematics modules see the manpage:
# $ man kins.
# KINEMATICS = trivkins coordinates=XYZA
KINEMATICS = trivkins coordinates=XYZBCUV

[TRAJ]
# The [TRAJ] section contains general parameters for the trajectory 
# planning module in motion
#
# The names of the axes being controlled. Only X, Y, Z, A, B, C, U, V,
# W are valid. Only axes named in COORDINATES are accepted in G-code.
# It is permitted to write an axis name more than once (e.g., X Y Y Z 
# for a gantry machine). For the common trivkins kinematics, joint
# numbers are assigned in sequence according to the trivkins parameter
# coordinates=. So, for trivkins coordinates=xz, joint0 corresponds to
# X and joint1 corresponds to Z. See the kinematics man page ($ man
# kins) for information on trivkins and other kinematics modules.
# COORDINATES =  XYZA
COORDINATES =  XYZBCUV
MAX_ANGULAR_VELOCITY = 360.00
DEFAULT_ANGULAR_VELOCITY = 36.00
# Specifies the machine units for linear axes. Possible choices are
# mm or inch. This does not affect the linear units in NC code (the
# G20 and G21 words do this).
LINEAR_UNITS = inch
# Specifies the machine units for rotational axes. Possible choices 
# are deg, degree (360 per circle), rad, radian (2*π per circle), 
# grad, or gon (400 per circle). This does not affect the angular
# units of NC code. In RS274NGC, A-, B- and C- words are always
# expressed in degrees.
ANGULAR_UNITS = degree
# The initial rate for jogs of linear axes, in machine units per 
# second. The value shown in AXIS equals machine units per minute.
DEFAULT_LINEAR_VELOCITY = 0.10
# The maximum velocity for any axis or coordinated move, in machine
# units per second. The value shown equals 300 units per minute.
MAX_LINEAR_VELOCITY = 1.00
# The default behavior is for LinuxCNC to force the user to home the
# machine before any MDI command or a program is run. Normally, only 
# jogging is allowed before homing. For configurations using identity
# kinematics, setting NO_FORCE_HOMING = 1 allows the user to make MDI
# moves and run programs without homing the machine first. Interfaces
# using identity kinematics without homing ability will need to have
# this option set to 1.
NO_FORCE_HOMING = 1

[EMCIO]
# Name of IO controller program.
EMCIO = io
# The period, in seconds, at which EMCIO will run. Making it 0.0 or a 
# negative number will tell EMCIO not to sleep at all. There is usually
# no need to change this number.
CYCLE_TIME = 0.100
# The file which contains tool information, described in the User 
# Manual.
TOOL_TABLE = tool.tbl

#******************************************
# Description of fields for [AXIS_#] and [JOINT_#] are also outlined
# in the Rosetta_ini.xlsx spreadsheet.

# [AXIS_#]
#
# Maximum velocity for this axis in machine units per second.
# MAX_VELOCITY = 360.0

# Maximum acceleration for this axis in machine units per second squared.
# MAX_ACCELERATION = 1200.0

# The minimum limit (soft limit) for axis motion, in machine units. 
# When this limit is exceeded, the controller aborts axis motion. The 
# axis must be homed before MIN_LIMIT is in force. For a rotary axis 
# (A,B,C typ) with unlimited rotation having no MIN_LIMIT for that axis
# in the [AXIS_<letter>] section a value of -1e99 is used.
# MIN_LIMIT = -9999.0

# The maximum limit (soft limit) for axis motion, in machine units.
# When this limit is exceeded, the controller aborts axis motion. The
# axis must be homed before MAX_LIMIT is in force. For a rotary axis
# (A,B,C typ) with unlimited rotation having no MAX_LIMIT for that axis
# in the [AXIS_<letter>] section a value of 1e99 is used.
# MAX_LIMIT = 9999.0

# [JOINT_3]
# The type of joint, either LINEAR or ANGULAR. 
# TYPE = ANGULAR

# The position that the joint will go to upon completion of the homing
# sequence.
# HOME = 0.0

# FERROR is the maximum allowable following error, in machine units. 
# If the difference between commanded and sensed position exceeds this
# amount, the controller disables servo calculations, sets all the 
# outputs to 0.0, and disables the amplifiers. If MIN_FERROR is present
# in the INI file, velocity-proportional following errors are used. 
# Here, the maximum allowable following error is proportional to the 
# speed, with FERROR applying to the rapid rate set by 
# [TRAJ]MAX_VELOCITY, and proportionally smaller following errors for
# slower speeds. The maximum allowable following error will always be
# greater than MIN_FERROR. This prevents small following errors for
# stationary axes from inadvertently aborting motion. Small following
# errors will always be present due to vibration, etc.
# FERROR = 0.5

# This is the value in machine units by which the joint is permitted to
# deviate from commanded position at very low speeds. If MIN_FERROR is
# smaller than FERROR, the two produce a ramp of error trip points. You
# could think of this as a graph where one dimension is speed and the
# other is permitted following error. As speed increases the amount of
# following error also increases toward the FERROR value.
# MIN_FERROR = 0.05

# (See Axis definition)
# MAX_VELOCITY = 360.0

# (See Axis definition)
# MAX_ACCELERATION = 1200.0

#Older configuration files have a velocity limit for the step generator
# as well. If specified, it should also be 1% to 10% larger than the
# joint MAX_VELOCITY. Subsequent testing has shown that use of
# STEPGEN_MAXVEL does not improve the tuning of StepGen’s position loop.
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
# STEPGEN_MAXVEL = 450.00

# Acceleration limit for the step generator. This should be 1% to 10% 
# larger than the joint MAX_ACCELERATION. This value improves the
# tuning of StepGen’s ”position loop”. If you have added backlash 
# compensation to an joint then this should be 1.5 to 2 times greater
# than MAX_ACCELERATION.
# STEPGEN_MAXACCEL = 1500.00

# The proportional gain for the joint servo. This value multiplies the
# error between commanded and actual position in machine units,
# resulting in a contribution to the computed voltage for the motor
# amplifier. The units on the P gain are volts per machine unit, e.g.,
# volts/unit
# P = 1000.0

# The integral gain for the joint servo. The value multiplies the 
# cumulative error between commanded and actual position in machine
# units, resulting in a contribution to the computed voltage for the
# motor amplifier. The units on the I gain are volts per machine unit 
# second, e.g., volts/unit second
# I = 0.0

# The derivative gain for the joint servo. The value multiplies the 
# difference between the current and previous errors, resulting in a 
# contribution to the computed voltage for the motor amplifier. The
# units on the D gain are volts per machine unit per second, e.g.,
# volts/unit second
# D = 0.0

# The 0th order feed forward gain. This number is multiplied by the 
# commanded position, resulting in a contribution to the computed
# voltage for the motor amplifier. The units on the FF0 gain are volts
# per machine unit, e.g., volts/unit
# FF0 = 0.0

# The 1st order feed forward gain. This number is multiplied by the
# change in commanded position per second, resulting in a contribution
# to the computed voltage for the motor amplifier. The units on the FF1
# gain are volts per machine unit per second, e.g., volts/unit second.
# FF1 = 1.0

# The 2nd order feed forward gain. This number is multiplied by the
# change in commanded position per second per second, resulting in a 
# contribution to the computed voltage for the motor amplifier. The
# units on the FF2 gain are volts per machine unit per second per
# second, e.g., volts/unit second2
# FF2 = 0.0

# This is used by hm2-servo and some others. Bias is a constant amount
# that is added to the output. In most cases it should be left at zero. 
# However, it can sometimes be useful to compensate for offsets in
# servo amplifiers, or to balance the weight of an object that moves 
# vertically. Bias is turned off when the PID loop is disabled, just
# like all other components of the output.
# BIAS = 0.0

# How close is close enough to consider the motor in position, in
# machine units.
#
# This is often set to a distance equivalent to 1, 1.5, 2, or 3 encoder 
# counts, but there are no strict rules. Looser (larger) settings allow
# less servo hunting at the expense of lower accuracy. Tighter
# (smaller) settings attempt higher accuracy at the expense of more
# servo hunting. Is it really more accurate if it’s also more
# uncertain? As a general rule, it’s good to avoid, or at least limit,
# servo hunting if you can.
#
# Be careful about going below 1 encoder count, since you may create a 
# condition where there is no place that your servo is happy. This can
# go beyond hunting (slow) to nervous (rapid), and even to squealing
# which is easy to confuse with oscillation caused by improper tuning.
# Better to be a count or two loose here at first, until you’ve been 
# through gross tuning at least.
# DEADBAND = 0.0

# The maximum value for the output of the PID compensation that is
# written to the motor amplifier, in volts. The computed output value
# is clamped to this limit. The limit is applied before scaling to raw 
# output units. The value is applied symmetrically to both the plus and
# the minus side.
# MAX_OUTPUT = 0.0

# these are in nanoseconds
# DIRSETUP   = 10000
# DIRHOLD    = 10000
# STEPLEN    = 5000
# STEPSPACE  = 5000

# Specifies the number of pulses that corresponds to a move of one
# machine unit as set in the [TRAJ] section. For stepper systems, this
# is the number of step pulses issued per machine unit. For a linear
# joint one machine unit will be equal to the setting of LINEAR_UNITS.
# For an angular joint one unit is equal to the setting in
# ANGULAR_UNITS. For servo systems, this is the number of feedback
# pulses per machine unit. A second number, if specified, is ignored.
#
# For example, on a 1.8 degree stepper motor with half-stepping, and 10 
# revs/inch gearing, and desired machine units of inch, we have:
#   input scale=2 steps/1.8 deg * 360 deg/rev * 10 rev/in = 4000 steps/in
# STEP_SCALE = 17.7778

# The minimum limit for joint motion, in machine units. When this limit
# is reached, the controller aborts joint motion. For a rotary joint
# with unlimited rotation having no MIN_LIMIT for that joint in the 
# [JOINT_N] section a the value -1e99 is used.
# MIN_LIMIT = -9999.0

# The maximum limit for joint motion, in machine units. When this limit
# is reached, the controller aborts joint motion. For a rotary joint
# with unlimited rotation having no MAX_LIMIT for that joint in the 
# [JOINT_N] section a the value 1e99 is used.
# MAX_LIMIT = 9999.0

# The joint position of the home switch or index pulse, in machine
# units. When the home point is found during the homing process, this
# is the position that is assigned to that point. When sharing home and
# limit switches and using a home sequence that will leave the
# home/limit switch in the toggled state, the home offset can be used 
# define the home switch position to be other than 0 if your HOME
# position is desired to be 0.
# HOME_OFFSET = 0.0

# Used to define the ”Home All” sequence. <n> must start at 0 or 1 or
# -1. Additional sequences may be specified with numbers increasing by
# 1 (in absolute value). Skipping of sequence numbers is not allowed.
# If a HOME_SEQUENCE is omitted, the joint will not be homed by the
# ”Home All” function. More than one joint can be homed at the same
# time by specifying the same sequence number for more than one joint.
# A negative sequence number is used to defer the final move for all
# joints having that (negative or positive) sequence number. For
# additional info, see: HOME SEQUENCE.
# HOME_SEQUENCE = 4

#******************************************
[AXIS_X]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
MIN_LIMIT = -9999.9
MAX_LIMIT = 9999.9

[JOINT_0]
TYPE = LINEAR
HOME = 0.0
FERROR = 0.5
MIN_FERROR = 0.05
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.50
P = 1000.0
I = 0.0
D = 0.0
FF0 = 0.0
FF1 = 1.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
MAX_OUTPUT = 0.0
# these are in nanoseconds
DIRSETUP   = 10000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
MIN_LIMIT = -9999.9
MAX_LIMIT = 9999.9
HOME_OFFSET = 0.0
HOME_SEQUENCE = 1
#******************************************

#******************************************
[AXIS_Y]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
MIN_LIMIT = -9999.9
MAX_LIMIT = 9999.9

[JOINT_1]
TYPE = LINEAR
HOME = 0.0
FERROR = 0.5
MIN_FERROR = 0.05
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.50
P = 1000.0
I = 0.0
D = 0.0
FF0 = 0.0
FF1 = 1.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
MAX_OUTPUT = 0.0
# these are in nanoseconds
DIRSETUP   = 10000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
MIN_LIMIT = -9999.9
MAX_LIMIT = 9999.9
HOME_OFFSET = 0.0
HOME_SEQUENCE = 2
#******************************************

#******************************************
[AXIS_Z]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
MIN_LIMIT = -9999.9
MAX_LIMIT = 9999.9

[JOINT_2]
TYPE = LINEAR
HOME = 0.0
FERROR = 0.5
MIN_FERROR = 0.05
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.50
P = 1000.0
I = 0.0
D = 0.0
FF0 = 0.0
FF1 = 1.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
MAX_OUTPUT = 0.0
# these are in nanoseconds
DIRSETUP   = 100000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
MIN_LIMIT = -9999.9
MAX_LIMIT = 9999.9
HOME_OFFSET = 0.0
HOME_SEQUENCE = 3
#******************************************

#******************************************
# Changes below added by  2025-02-13 by R. Colvin
# Removed Axis A as it is not used

# [AXIS_A]
# MAX_VELOCITY = 360.0
# MAX_ACCELERATION = 1200.0
# MIN_LIMIT = -9999.0
# MAX_LIMIT = 9999.0

# [JOINT_3]
# TYPE = ANGULAR
# HOME = 0.0
# FERROR = 0.5
# MIN_FERROR = 0.05
# MAX_VELOCITY = 360.0
# MAX_ACCELERATION = 1200.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
# STEPGEN_MAXVEL = 450.00
# STEPGEN_MAXACCEL = 1500.00
# P = 1000.0
# I = 0.0
# D = 0.0
# FF0 = 0.0
# FF1 = 1.0
# FF2 = 0.0
# BIAS = 0.0
# DEADBAND = 0.0
# MAX_OUTPUT = 0.0
# these are in nanoseconds
# DIRSETUP   = 10000
# DIRHOLD    = 10000
# STEPLEN    = 5000
# STEPSPACE  = 5000
# STEP_SCALE = 17.7778
# MIN_LIMIT = -9999.0
# MAX_LIMIT = 9999.0
# HOME_OFFSET = 0.0
# HOME_SEQUENCE = 4
#******************************************

# Axis B Added
[AXIS_B]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0

[JOINT_3]
TYPE = ANGULAR
HOME = 0.0
FERROR = 0.5
MIN_FERROR = 0.05
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.50
P = 1000.0
I = 0.0
D = 0.0
FF0 = 0.0
FF1 = 1.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
MAX_OUTPUT = 0.0
# these are in nanoseconds
DIRSETUP   = 10000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0
HOME_OFFSET = 0.0
HOME_SEQUENCE = 4
#******************************************

# Axis C Added
[AXIS_C]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0

[JOINT_4]
TYPE = ANGULAR
HOME = 0.0
FERROR = 0.5
MIN_FERROR = 0.05
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.50
P = 1000.0
I = 0.0
D = 0.0
FF0 = 0.0
FF1 = 1.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
MAX_OUTPUT = 15.0
# these are in nanoseconds
DIRSETUP   = 10000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0
HOME_OFFSET = 0.0
HOME_SEQUENCE = 5
#******************************************

# Axis U Added
[AXIS_U]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0

[JOINT_5]
TYPE = LINEAR
HOME = 0.0
FERROR = 0.5
MIN_FERROR = 0.05
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.5
P = 1000.0
I = 0.0
D = 0.0
FF0 = 0.0
FF1 = 1.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
MAX_OUTPUT = 0.0
# these are in nanoseconds
DIRSETUP   = 10000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0
HOME_OFFSET = 0.0
HOME_SEQUENCE = 6
#******************************************

# Axis V Added
[AXIS_V]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0

[JOINT_6]
TYPE = LINEAR
HOME = 0.0
FERROR = 0.5
MIN_FERROR = 0.05
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.50
P = 1000.0
I = 0.0
D = 0.0
FF0 = 0.0
FF1 = 1.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
MAX_OUTPUT = 0.0
# these are in nanoseconds
DIRSETUP   = 10000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
MIN_LIMIT = -9999.0
MAX_LIMIT = 9999.0
HOME_OFFSET = 0.0
HOME_SEQUENCE = 7
#******************************************

[SPINDLE_0]
MAX_VELOCITY = 1.0
MAX_ACCELERATION = 30.0
# The values below should be 25% larger than MAX_VELOCITY and MAX_ACCELERATION
# If using BACKLASH compensation STEPGEN_MAXACCEL should be 100% larger.
STEPGEN_MAXVEL = 1.25
STEPGEN_MAXACCEL = 37.50
P = 0.0
I = 0.0
D = 0.0
FF0 = 1.0
FF1 = 0.0
FF2 = 0.0
BIAS = 0.0
DEADBAND = 0.0
# MAX_OUTPUT = 166.66666666666666
MAX_OUTPUT = 15.0
# these are in nanoseconds
DIRSETUP   = 10000
DIRHOLD    = 10000
STEPLEN    = 5000
STEPSPACE  = 5000
STEP_SCALE = 6400.0
# Sets the step size for spindle speed increment / decrement commands. 
# This can have a different value for each spindle. This setting is 
# effective with AXIS and Touchy but note that some control screens may 
# handle things differently.
INCREMENT = 0.1
